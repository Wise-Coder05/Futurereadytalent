package time;
import java.util.ArrayList;
import java.util.Set;
import appliance.core.Appliance;
import policy.core.PolicyComponent;

/**A TimedEventHandler implementation that executes TimedEvents hierarchically
 * based on their role, allowing for weaker TimedEvents to be overruled by those
 * deemed more important, such as Balance Load request
 *
 * @author Darius Hodaei <k1183257@kcl.ac.uk>
 */
public class PriorityTimedEventHandler implements ITimedEventHandler {
    /**All of the TimedEvents list*/
    private ArrayList[] events;
    
    /**The number of different TimedEvent types, and therefore the number of lists*/
    private final int EVENT_LISTS = 4;
    // Order of precedence (lowest -> highest):
    /**A constant for Appliance generated events, such as usage hours*/
    private final int APPLIANCE_EVENTS = 0;
    /**A constant for House generated events*/
    private final int HOUSE_EVENTS = 1;
    /**A constant for Policy generated events*/
    private final int POLICY_EVENTS = 2;
    /**A constant for Balance Load requests, the most important TimedEvents*/
    private final int BALANCE_LOAD_EVENTS = 3;

    /**Wrapper class so that TimedEvents that generate from a PolicyComponent
     * can be tracked easily, allowing us to know the originator of a particular
     * TimedEvent - Useful for the GUI, and also when adding appliances to the house
     * that might be affected by a particular policy
     */
    private class PolicyTimedEventTag {
        /**The PolicyComponent to associate with the policy generated TimedEvents*/
        PolicyComponent tag;
        /**The TimedEvents that are generated by the associated PolicyComponent*/
        ArrayList<TimedEvent> policyEvents;

        private PolicyTimedEventTag(PolicyComponent tag) {
            this.tag = tag;
            policyEvents = new ArrayList<TimedEvent>();
            // Add the tag to the global list
            events[POLICY_EVENTS].add(this);
        }
    }

    
    public PriorityTimedEventHandler() {

        // create all of the TimedEvent lists that we manage
        events = new ArrayList[EVENT_LISTS];
        events[APPLIANCE_EVENTS] = new ArrayList<ApplianceTimedEvent>();
        events[HOUSE_EVENTS] = new ArrayList<HouseTimedEvent>();

        events[BALANCE_LOAD_EVENTS] = new ArrayList<ApplianceTimedEvent>();

        // This allows us to iterate over tagged policy events but still
        // store them in this array structure neatly :)
        events[POLICY_EVENTS] = new ArrayList<PolicyTimedEventTag>();

    }

    public void coordinatedExecution() {

        /* Prioritised execution of event lists so that there is an implicit
         * order of precendence:
         *
         * 1 Appliance Events   - overwritable by...
         * 2 House Events       - overwritable by...
         * 3 Policy Events      - overwritable by...
         * 4 Balance Load Events
         *
         * 1 and 2 are basic rules of the system, whereas 3 and 4 are dynamic
         * and thus, take precendence whenever they are required.
         */

        /************* APPLIANCE EVENTS ***************************/
        for (int x = 0; x < events[APPLIANCE_EVENTS].size(); ++x) {

            // Retrieve each TimedEvent in turn
            TimedEvent te = (TimedEvent) events[APPLIANCE_EVENTS].get(x);

            // Execute it
            te.checkEvent();
            // If it has finished remove it from the list
            if (te.hasFinished()) {
                events[APPLIANCE_EVENTS].remove(x);
            }



        }

        /************* HOUSE EVENTS ***************************/
        for (int x = 0; x < events[HOUSE_EVENTS].size(); ++x) {
            // Retrieve each TimedEvent in turn
            TimedEvent te = (TimedEvent) events[HOUSE_EVENTS].get(x);
            // Execute it
            te.checkEvent();
            // If it has finished remove it from the list
            if (te.hasFinished()) {
                events[HOUSE_EVENTS].remove(x);
            }
        }

        /************* POLICY EVENTS ***************************/
        for (int x = 0; x < events[POLICY_EVENTS].size(); ++x) {
            PolicyTimedEventTag t = (PolicyTimedEventTag) events[POLICY_EVENTS].get(x);
            for (int y = 0; y < t.policyEvents.size(); y++) {

                // Retrieve each TimedEvent in turn
                TimedEvent te = t.policyEvents.get(y);
                // Execute it
                te.checkEvent();
                // If it has finished remove it from the list

                if (te.hasFinished()) {
                    t.policyEvents.remove(y);
                }

            }

        }

        /************* BALANCE LOAD EVENTS ***************************/
        for (int x = 0; x < events[BALANCE_LOAD_EVENTS].size(); ++x) {
            // Retrieve each TimedEvent in turn
            TimedEvent te = (TimedEvent) events[BALANCE_LOAD_EVENTS].get(x);
            // Execute it
            te.checkEvent();
            // If it has finished remove it from the list
            if (te.hasFinished()) {
                events[BALANCE_LOAD_EVENTS].remove(x);
            }
        }
    }

    /* NOTE: The implemented methods' signatures require Sets to ensure that no
     * duplicate events are passed through to the ITimedEventHandler. In the
     * underlying implementation we actually use ArrayLists to give us flexible
     * access and modification of the collection.
     */
    public void submitGeneralHouseEvents(Set<HouseTimedEvent> timedEvents) {
        terminateEvents(events[HOUSE_EVENTS]);

        events[HOUSE_EVENTS] = new ArrayList(timedEvents);
    }

    public void submitGeneralApplianceEvents(Set<ApplianceTimedEvent> timedEvents) {
        // we can only add the ApplianceTimedEvent if it does not already exist
        for (ApplianceTimedEvent ate : timedEvents) {
            if (!events[APPLIANCE_EVENTS].contains(ate)) {
                events[APPLIANCE_EVENTS].add(ate);
            }
        }
    }

    public void removeGeneralApplianceEvents(Appliance appliance) {
        // We look through all of the ApplianceTimedEvents
        for (int index = 0; index < events[APPLIANCE_EVENTS].size(); ++index) {
            // If this particular event references the same appliance
            if (((ApplianceTimedEvent) events[APPLIANCE_EVENTS].get(index)).getRegisteredAppliance() == appliance) {
                // Remove the event
                events[APPLIANCE_EVENTS].remove(index);

                // IN ORDER TO AVOID NULL POINTERS WE HAVE TO ALSO REMOVE ANY POLICIES
                // THAT WERE ATTACHED TO IT
                for (int xx = 0; xx < events[POLICY_EVENTS].size(); xx++) {
                    Object polEvent = events[POLICY_EVENTS].get(xx);
                    if (polEvent.getClass() == ApplianceTimedEvent.class) {
                        ApplianceTimedEvent ate = (ApplianceTimedEvent) polEvent;

                        if (ate.getRegisteredAppliance() == appliance) {
                            events[POLICY_EVENTS].remove(ate);
                        }
                    }
                }
            }
        }

    }

    /**Enforces the end of the given TimedEvents at the request of the caller,
     * regardless of their current state
     *
     * @param timedEvents the TimedEvents to terminate
     */
    private void terminateEvents(ArrayList<TimedEvent> timedEvents) {
        // terminate each event in turn
        for (int index = 0; index < timedEvents.size(); ++index) {
            terminateEvent(timedEvents.get(index));
        }
    }

    /**Enforces the end of the given TimedEvent at the request of the caller,
     * regardless of its current state
     *
     * @param timedEvent the TimedEvent to terminate
     */
    private void terminateEvent(TimedEvent timedEvent) {
        timedEvent.terminate();
    }

    public void submitPolicyEvents(PolicyComponent pc) {
        for (int x = 0; x < events[POLICY_EVENTS].size(); x++) {
            // retrieve and cast the object
            PolicyTimedEventTag t = (PolicyTimedEventTag) events[POLICY_EVENTS].get(x);
            // if this tag equals the policy component arg
            if (t.tag == pc) {

                for (TimedEvent te : pc.generalRules()) {
                    if (!t.policyEvents.contains(te)) {
                        t.policyEvents.add(te);
                    }
                }

                return; // done what we need to do
            }
        }
        // if we get here then the policy component wasn't in our tagged list, so add it
        PolicyTimedEventTag newOne = new PolicyTimedEventTag(pc);
        newOne.policyEvents.addAll(pc.generalRules());
        
    }

    public ArrayList<TimedEvent> getCurrentPolicyTimedEvents(PolicyComponent pc) {

        for (int x = 0; x < events[POLICY_EVENTS].size(); x++) {
            // retrieve and cast the object
            PolicyTimedEventTag t = (PolicyTimedEventTag) events[POLICY_EVENTS].get(x);
            // if this tag equals the policy component arg
            if (t.tag == pc) {
                return t.policyEvents;
            }
        }
        return new ArrayList<TimedEvent>(0);
    }

    public void addApplianceApplicablePolicyEvents(Appliance a){
       // Go through all tagged policies
       for (int x = 0; x < events[POLICY_EVENTS].size(); x++) {
            // retrieve and cast the object
            PolicyTimedEventTag ptet = (PolicyTimedEventTag) events[POLICY_EVENTS].get(x);
            // we need to examine all of the timed this policy would generate
            for(TimedEvent te : ptet.tag.generalRules()){
                // if this TimedEvent is an ApplianceTimedEvent
                if(te.getClass() == ApplianceTimedEvent.class){
                    // if the Appliance it applies to matches the class of the given appliance
                    if(((ApplianceTimedEvent)te).getRegisteredAppliance().getClass()
                            == a.getClass()){
                        // Add the Timed Event to the tagged policy
                        ptet.policyEvents.add(te);
                    }
                }
            }

        }
    }

    public void removeApplianceApplicablePolicyEvents(Appliance a){
       // Go through all tagged policies
       for (int x = 0; x < events[POLICY_EVENTS].size(); x++) {
            // retrieve and cast the object
            PolicyTimedEventTag ptet = (PolicyTimedEventTag) events[POLICY_EVENTS].get(x);
            // we need to examine all of the timed this policy would generate
            for(int y = 0; y < ptet.policyEvents.size(); y++)
            {
                TimedEvent te = ptet.policyEvents.get(y);
                // if this TimedEvent is an ApplianceTimedEvent
                if(te.getClass() == ApplianceTimedEvent.class){
                    // if the Appliance it applies to matches the given appliance
                    if(((ApplianceTimedEvent)te).getRegisteredAppliance() == a){
                        // Remove the Timed Event from the tagged policy
                        ptet.policyEvents.remove(te);
                    }
                }
            }

        }
    }


    public void removePolicyEvents(Set<TimedEvent> timedEvents) {

        for (TimedEvent te : timedEvents) {
            for (int i = 0; i < events[POLICY_EVENTS].size(); ++i) {
                TimedEvent t = (TimedEvent) events[POLICY_EVENTS].get(i);
                if (t == te) {
                    terminateEvent(t);
                    events[POLICY_EVENTS].remove(i);
                }
            }
        }
    }

    public void submitBalanceLoadEvents(Set<ApplianceTimedEvent> timedEvents) {
        //terminateEvents(events[BALANCE_LOAD_EVENTS]);
        //events[BALANCE_LOAD_EVENTS] = new ArrayList(timedEvents);
        events[BALANCE_LOAD_EVENTS].addAll(timedEvents);
    }
}
